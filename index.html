<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Transformador Lógico FOL — Prenex / CNF / DNF / Cláusal</title>

  <!-- MathJax -->
  <script>
    window.MathJax = {tex:{inlineMath:[['$','$'],['\\(','\\)']]}, svg:{fontCache:'global'}};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=Roboto+Slab:wght@600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #f7fbfb;
      --panel: #ffffff;
      --muted: #546e7a;
      --text: #0f1723;
      --accent: #0f766e;        /* teal dark */
      --accent-2: #ff6a3d;      /* orange accent */
      --border: #e6eef0;
      --glass: rgba(15,23,35,0.03);
      --shadow: 0 6px 18px rgba(17,24,39,0.06);
      --mono: "SF Mono", "Fira Code", Menlo, Monaco, monospace;
    }

    html,body { height:100%; }
    body{
      margin:0;
      background: linear-gradient(180deg, #f5fbfb 0%, #f7f9fa 100%);
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:28px;
      line-height:1.5;
    }

    .wrap {
      max-width:1040px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:20px;
      align-items:start;
    }

    /* SIDEBAR */
    .sidebar {
      background: linear-gradient(180deg, rgba(15,118,110,0.06), rgba(255,106,61,0.02));
      border:1px solid var(--border);
      border-radius:12px;
      padding:18px;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
      gap:14px;
      min-height:220px;
    }
    .brand {
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo {
      width:46px;
      height:46px;
      border-radius:10px;
      background: linear-gradient(135deg,var(--accent),var(--accent-2));
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:700;
      font-family: "Roboto Slab", serif;
      box-shadow: 0 6px 16px rgba(15,118,110,0.15);
    }
    .brand h1 {
      margin:0;
      font-size:1.05rem;
      line-height:1.1;
      font-family:"Roboto Slab", serif;
      color:var(--text);
      font-weight:700;
    }
    .subtitle {
      color:var(--muted);
      font-size:0.86rem;
      margin-top:4px;
    }

    .help {
      font-size:0.9rem;
      color:var(--muted);
      background:var(--glass);
      padding:10px;
      border-radius:8px;
      border:1px solid rgba(15,23,35,0.03);
    }

    /* MAIN CARD */
    .card {
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:18px;
      box-shadow:var(--shadow);
    }

    .input-header {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      margin-bottom:12px;
    }
    .input-header .title {
      display:flex;
      flex-direction:column;
    }
    .input-header h2 {
      margin:0;
      font-family:"Roboto Slab", serif;
      font-size:1.15rem;
      color:var(--text);
    }
    .input-header p { margin:4px 0 0 0; color:var(--muted); font-size:0.9rem; }

    .symbols {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin:12px 0;
    }
    .symbol-btn {
      background:transparent;
      border:1px dashed rgba(15,23,35,0.06);
      padding:8px 10px;
      border-radius:10px;
      font-weight:600;
      cursor:pointer;
      font-size:15px;
      min-width:44px;
      text-align:center;
      transition:transform .14s ease, box-shadow .14s ease, background .14s ease;
    }
    .symbol-btn:active{ transform:translateY(1px); }
    .symbol-btn:hover{
      background:linear-gradient(90deg, rgba(15,118,110,0.06), rgba(255,106,61,0.03));
      box-shadow: 0 6px 18px rgba(15,118,110,0.06);
    }

    textarea#input {
      width:100%;
      min-height:130px;
      box-sizing:border-box;
      padding:12px 14px;
      font-family:var(--mono);
      font-size:15px;
      border-radius:10px;
      border:1px solid var(--border);
      resize:vertical;
      color:var(--text);
      background: linear-gradient(180deg,#ffffff,#fcfeff);
      transition:box-shadow .15s ease, border-color .15s ease;
    }
    textarea#input:focus {
      outline:none;
      border-color:var(--accent);
      box-shadow: 0 8px 20px rgba(15,118,110,0.06);
    }

    .actions {
      display:flex;
      gap:10px;
      margin-top:12px;
      align-items:center;
    }
    .btn-primary {
      background: linear-gradient(90deg,var(--accent), #0b8b80);
      border:0;
      padding:10px 14px;
      border-radius:10px;
      color:#fff;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 8px 20px rgba(15,118,110,0.12);
      transition:transform .12s ease, opacity .12s ease;
    }
    .btn-primary:hover { transform:translateY(-3px); opacity:0.98; }

    .btn-secondary {
      background:transparent;
      border:1px solid var(--border);
      padding:9px 12px;
      border-radius:10px;
      color:var(--muted);
      cursor:pointer;
      font-weight:600;
    }

    /* examples area */
    .examples {
      margin-top:18px;
      display:flex;
      gap:12px;
      flex-direction:column;
    }
    .examples .group-title {
      font-size:0.89rem;
      color:var(--muted);
      font-weight:700;
      letter-spacing:0.4px;
    }
    .chips {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip {
      background:linear-gradient(180deg,#f1f7f7,#ffffff);
      border:1px solid var(--border);
      padding:8px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      transition:transform .12s ease, background .12s ease;
      color:var(--accent);
    }
    .chip:hover { transform:translateY(-4px); background:linear-gradient(90deg, rgba(15,118,110,0.06), rgba(255,106,61,0.04)); color:var(--text); }

    /* results */
    #resultsContainer {
      margin-top:20px;
    }
    #resultsContainer h3 {
      margin:14px 0 10px 0;
      font-family:"Roboto Slab", serif;
      font-size:1.02rem;
    }
    .step {
      background:linear-gradient(180deg,#ffffff,#fbfeff);
      border:1px solid var(--border);
      padding:14px;
      border-radius:10px;
      margin-bottom:12px;
      display:flex;
      gap:14px;
      align-items:flex-start;
      box-shadow:0 10px 25px rgba(11,13,20,0.03);
    }
    .step-number {
      min-width:36px;
      min-height:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      background:linear-gradient(180deg,var(--accent),var(--accent-2));
      color:white;
      font-weight:800;
      font-family:"Roboto Slab", serif;
    }
    .step-content .title { font-weight:700; color:var(--text); margin-bottom:6px; }
    .step-content .formula { font-family:var(--mono); color:#0b1720; background:transparent; }

    .step.error { border-color: #f7d7d6; background: linear-gradient(180deg,#fff6f6,#fffdfd); }
    .muted-block { color:var(--muted); font-size:0.9rem; }

    @media (max-width:920px){
      .wrap{ grid-template-columns: 1fr; padding:12px; }
      .sidebar{ order:2; }
    }

  </style>
</head>
<body>
  <div class="wrap">
    <!-- SIDEBAR -->
    <aside class="sidebar" aria-label="Informações">
      <div class="brand">
        <div class="logo">FOL</div>
        <div>
          <h1>Transformador Lógico</h1>
          <div class="subtitle">Prenex · CNF · DNF · Forma Cláusal</div>
        </div>
      </div>

      <div class="help">
        Cole uma fórmula em LaTeX (ex.: <code>\forall x (P(x) \rightarrow Q(x))</code>) e pressione <strong>Processar</strong>.
        Use os símbolos rápidos para inserir quantificadores e conectivos.
      </div>

      <div class="muted-block" style="margin-top:6px;">
      </div>
    </aside>

    <!-- MAIN -->
    <main class="card" role="main" aria-labelledby="main-title">
      <div class="input-header">
        <div class="title">
          <h2 id="main-title">Editor de Fórmulas</h2>
          <p>Insira a fórmula em LaTeX. O transformador exibirá passos intermediários.</p>
        </div>
        <div class="muted-block">Saída renderizada com MathJax</div>
      </div>

      <div class="symbols" aria-hidden="false">
        <button class="symbol-btn" onclick="inserirSimbolo('\\forall ')">∀</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\exists ')">∃</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\neg ')">¬</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\land ')">∧</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\lor ')">∨</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\rightarrow ')">→</button>
        <button class="symbol-btn" onclick="inserirSimbolo('\\leftrightarrow ')">↔</button>
      </div>

      <textarea id="input" spellcheck="false" placeholder="Digite a fórmula aqui...">\forall x (Homem(x) \rightarrow Mortal(x))</textarea>

      <div class="actions">
        <button class="btn-primary" onclick="executarTudo()">Processar</button>
        <button class="btn-secondary" onclick="limparTudo()">Limpar</button>
        <div style="flex:1"></div>
      </div>

      <div class="examples">
        <div>
          <div class="group-title">Básicos</div>
          <div class="chips">
            <div class="chip" onclick="definirExemplo('P \\rightarrow (Q \\land R)')">P → (Q ∧ R)</div>
            <div class="chip" onclick="definirExemplo('\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)')">De Morgan (¬(P∧Q))</div>
            <div class="chip" onclick="definirExemplo('(A \\lor B) \\land (\\neg A \\lor C)')">Conjunção / Disjunção</div>
          </div>
        </div>

        <div>
          <div class="group-title">Quantificadores</div>
          <div class="chips">
            <div class="chip" onclick="definirExemplo('\\exists y \\forall x \\; P(x,y)')">∃y ∀x P(x,y)</div>
            <div class="chip" onclick="definirExemplo('\\neg \\exists x \\forall y (P(y) \\rightarrow Q(x))')">Negação de ∃∀</div>
          </div>
        </div>

        <div>
          <div class="group-title">Exemplos Clássicos (substituídos)</div>
          <div class="chips">
            <div class="chip" onclick="definirExemplo('\\forall x (Primo(x) \\rightarrow Odd(x))')">Primos são ímpares?</div>
            <div class="chip" onclick="definirExemplo('\\forall x (Gato(x) \\rightarrow Animal(x))')">Gatos → Animais</div>
            <div class="chip" onclick="definirExemplo('\\exists x (Humano(x) \\land Voa(x))')">Existe humano que voa?</div>
          </div>
        </div>
      </div>

      <div id="resultsContainer" aria-live="polite"></div>
    </main>
  </div>

  <script>
    /* --- Mantive a lógica de transformação praticamente igual ao original.
       Apenas removi todo o código relacionado a tema escuro/claro. --- */

    function tokenizar(s) {
      s = s.replace(/\$/g, ' ').trim();
      const tokens = [];
      const padroes = [
        ["WS", /^\s+/],["FORALL", /^(\\forall|∀)/],["EXISTS", /^(\\exists|∃)/],["NOT", /^(\\neg|¬|\\lnot)/],["AND", /^(\\land|∧)/],["OR", /^(\\lor|∨)/],["IMPLIES", /^(\\rightarrow|→)/],["IFF", /^(\\leftrightarrow|↔)/],["LPAREN", /^\(/],["RPAREN", /^\)/],["COMMA", /^,/],["DOT", /^\./],["IDENT", /^[A-Za-z_][A-Za-z0-9_]*/],["UNKNOWN", /^./]
      ];
      let i = 0;
      while (i < s.length) {
        let matched = false;
        for (const [tipo, re] of padroes) {
          const m = s.slice(i).match(re);
          if (m) {
            matched = true;
            const tok = m[0];
            if (tipo !== "WS") tokens.push({ tipo, valor: tok });
            i += tok.length;
            break;
          }
        }
        if (!matched) i++;
      }
      return tokens;
    }

    function analisar(s) {
      const tokens = tokenizar(s);
      let pos = 0;
      const peek = () => tokens[pos] || null;
      const eat = tipo => (peek() && peek().tipo === tipo ? tokens[pos++] : null);
      const expect = tipo => {
        const t = eat(tipo);
        if (!t) throw new Error(`Esperado ${tipo}, encontrado ${peek()?.tipo || 'fim'}`);
        return t;
      };

      function formula() { return iff(); }
      function iff() {
        let left = implies();
        while (peek() && peek().tipo === "IFF") {
          eat("IFF");
          left = { tipo: 'iff', a: left, b: implies() };
        }
        return left;
      }
      function implies() {
        let left = or();
        if (peek() && peek().tipo === "IMPLIES") {
          eat("IMPLIES");
          left = { tipo: 'implies', a: left, b: implies() };
        }
        return left;
      }
      function or() {
        let left = and();
        while (peek() && peek().tipo === "OR") {
          eat("OR");
          left = { tipo: 'or', a: left, b: and() };
        }
        return left;
      }
      function and() {
        let left = unary();
        while (peek() && peek().tipo === "AND") {
          eat("AND");
          left = { tipo: 'and', a: left, b: unary() };
        }
        return left;
      }
      function unary() {
        const t = peek();
        if (!t) return null;
        if (t.tipo === "NOT") { eat("NOT"); return { tipo: 'not', a: unary() }; }
        if (t.tipo === "FORALL" || t.tipo === "EXISTS") {
          const qtipo = t.tipo === "FORALL" ? 'forall' : 'exists';
          eat(t.tipo);
          const vars = [];
          while (peek() && peek().tipo === "IDENT") vars.push(eat("IDENT").valor);
          if (!vars.length) throw new Error(`Esperado variável após ${qtipo === 'forall' ? '∀' : '∃'}`);
          if (peek() && peek().tipo === "DOT") eat("DOT");
          let node = formula();
          if (!node) throw new Error(`Esperado fórmula após quantificador`);
          for (let i = vars.length - 1; i >= 0; i--) node = { tipo: qtipo, var: vars[i], a: node };
          return node;
        }
        if (t.tipo === "LPAREN") { eat("LPAREN"); const f = formula(); expect("RPAREN"); return f; }
        if (t.tipo === "IDENT") {
          const nome = eat("IDENT").valor;
          if (peek() && peek().tipo === "LPAREN") {
            eat("LPAREN");
            const args = [];
            if (peek() && peek().tipo !== "RPAREN") {
              while (true) {
                if (peek().tipo === "IDENT") args.push({ tipo: 'var', nome: eat("IDENT").valor });
                else throw new Error(`Token inesperado em argumentos: ${peek().tipo}`);
                if (peek() && peek().tipo === "COMMA") eat("COMMA");
                else break;
              }
            }
            expect("RPAREN");
            return { tipo: 'pred', nome, args };
          }
          return { tipo: 'pred', nome, args: [] };
        }
        throw new Error(`Token inesperado: ${t.tipo}`);
      }
      const ast = formula();
      if (pos < tokens.length) throw new Error(`Tokens extras encontrados: ${tokens.slice(pos).map(t => t.valor).join(' ')}`);
      return ast;
    }

    const clone = x => JSON.parse(JSON.stringify(x));

    function astParaLatex(a) {
      if (!a) return '';
      const wrap = (x, parent_op) => {
        if (!x) return '';
        const op_precedence = { 'iff': 1, 'implies': 2, 'or': 3, 'and': 4, 'not': 5, 'quant': 6 };
        const p_prec = op_precedence[parent_op] || 0;
        const c_prec = op_precedence[x.tipo] || 0;
        const needs_paren = c_prec < p_prec;
        return needs_paren ? `(${astParaLatex(x)})` : astParaLatex(x);
      };
      switch (a.tipo) {
        case 'pred': return a.args && a.args.length ? `${a.nome}(${a.args.map(termoParaLatex).join(',')})` : a.nome;
        case 'not': return `\\lnot ${wrap(a.a, 'not')}`;
        case 'and': return `${wrap(a.a, 'and')} \\land ${wrap(a.b, 'and')}`;
        case 'or': return `${wrap(a.a, 'or')} \\lor ${wrap(a.b, 'or')}`;
        case 'implies': return `${wrap(a.a, 'implies')} \\rightarrow ${wrap(a.b, 'implies')}`;
        case 'iff': return `${wrap(a.a, 'iff')} \\leftrightarrow ${wrap(a.b, 'iff')}`;
        case 'forall': return `\\forall ${a.var} \\, ${astParaLatex(a.a)}`;
        case 'exists': return `\\exists ${a.var} \\, ${astParaLatex(a.a)}`;
        case 'func': return a.args && a.args.length ? `${a.nome}(${a.args.map(termoParaLatex).join(',')})` : a.nome;
        case 'var': return a.nome;
        default: return '\\text{?}';
      }
    }

    function termoParaLatex(t) {
      if (!t) return '';
      if (t.tipo === 'var') return t.nome;
      if (t.tipo === 'func') return t.args && t.args.length ? `${t.nome}(${t.args.map(termoParaLatex).join(',')})` : t.nome;
      return t.nome || '?';
    }

    function eliminarImplicacoes(node) {
      if (!node) return node;
      switch (node.tipo) {
        case 'implies': return { tipo: 'or', a: { tipo: 'not', a: eliminarImplicacoes(node.a) }, b: eliminarImplicacoes(node.b) };
        case 'iff': return eliminarImplicacoes({ tipo: 'and', a: { tipo: 'implies', a: node.a, b: node.b }, b: { tipo: 'implies', a: node.b, b: node.a } });
        case 'and': case 'or': return { tipo: node.tipo, a: eliminarImplicacoes(node.a), b: eliminarImplicacoes(node.b) };
        case 'not': return { tipo: 'not', a: eliminarImplicacoes(node.a) };
        case 'forall': case 'exists': return { tipo: node.tipo, var: node.var, a: eliminarImplicacoes(node.a) };
        default: return clone(node);
      }
    }

    function paraNNF(node) {
      if (!node) return node;
      function nnf(n, neg) {
        if (!n) return null;
        if (n.tipo === 'not') return nnf(n.a, !neg);
        if (n.tipo === 'and' || n.tipo === 'or') {
          const a = nnf(n.a, neg), b = nnf(n.b, neg);
          if (neg) return n.tipo === 'and' ? { tipo: 'or', a, b } : { tipo: 'and', a, b };
          return { tipo: n.tipo, a, b };
        }
        if (n.tipo === 'forall' || n.tipo === 'exists') {
          if (neg) return { tipo: n.tipo === 'forall' ? 'exists' : 'forall', var: n.var, a: nnf(n.a, true) };
          return { tipo: n.tipo, var: n.var, a: nnf(n.a, false) };
        }
        return neg ? { tipo: 'not', a: clone(n) } : clone(n);
      }
      return nnf(node, false);
    }

    let skContador = 0, renomearContador = 0;
    const novoSk = (p = 'sk') => p + (++skContador);
    const novaVar = (p = 'v') => p + (++renomearContador);

    function getVars(node, bound = new Set()) {
      if (!node) return new Set();
      switch(node.tipo) {
        case 'pred': return new Set(node.args.map(arg => arg.nome));
        case 'not': return getVars(node.a, bound);
        case 'and': case 'or': case 'implies': case 'iff': return new Set([...getVars(node.a, bound), ...getVars(node.b, bound)]);
        case 'forall': case 'exists': {
          const newBound = new Set(bound);
          newBound.add(node.var);
          return new Set([node.var, ...getVars(node.a, newBound)]);
        }
        default: return new Set();
      }
    }

    function renomearVariaveisLigadas(node, mapping = {}, allVars = getVars(node)) {
      if (!node) return node;
      switch (node.tipo) {
        case 'forall':
        case 'exists': {
          let newVar = node.var;
          const newMapping = { ...mapping };
          let nv = novaVar(node.var);
          newMapping[node.var] = nv;
          return { tipo: node.tipo, var: nv, a: renomearVariaveisLigadas(node.a, newMapping, allVars) };
        }
        case 'and': case 'or': return { tipo: node.tipo, a: renomearVariaveisLigadas(node.a, mapping, allVars), b: renomearVariaveisLigadas(node.b, mapping, allVars) };
        case 'not': return { tipo: 'not', a: renomearVariaveisLigadas(node.a, mapping, allVars) };
        case 'pred': return { tipo: 'pred', nome: node.nome, args: node.args.map(arg => ({ ...arg, nome: mapping[arg.nome] || arg.nome })) };
        default: return clone(node);
      }
    }

    function puxarQuantificadores(node) {
      if (!node) return { quantificadores: [], matriz: null };
      if (node.tipo === 'forall' || node.tipo === 'exists') {
        const interno = puxarQuantificadores(node.a);
        return { quantificadores: [{ tipo: node.tipo, var: node.var }, ...interno.quantificadores], matriz: interno.matriz };
      }
      if (node.tipo === 'and' || node.tipo === 'or') {
        const E = puxarQuantificadores(node.a), D = puxarQuantificadores(node.b);
        return { quantificadores: [...E.quantificadores, ...D.quantificadores], matriz: { tipo: node.tipo, a: E.matriz, b: D.matriz } };
      }
      if (node.tipo === 'not') {
        const P = puxarQuantificadores(node.a);
        return { quantificadores: P.quantificadores, matriz: { tipo: 'not', a: P.matriz } };
      }
      return { quantificadores: [], matriz: clone(node) };
    }

    function construirPrenex(quantificadores, matriz) {
      let node = clone(matriz);
      for (let i = quantificadores.length - 1; i >= 0; --i)
        node = { tipo: quantificadores[i].tipo, var: quantificadores[i].var, a: node };
      return node;
    }

    function skolemizar(nodePrenex) {
      const qlist = [];
      let cur = nodePrenex;
      while (cur && (cur.tipo === 'forall' || cur.tipo === 'exists')) {
        qlist.push({ tipo: cur.tipo, var: cur.var });
        cur = cur.a;
      }
      let matriz = cur;
      const prefixoUniversal = [];
      const subs = {};
      for (const q of qlist) {
        if (q.tipo === 'forall') prefixoUniversal.push(q.var);
        else {
          subs[q.var] = prefixoUniversal.length === 0
            ? { tipo: 'func', nome: novoSk('c'), args: [] }
            : { tipo: 'func', nome: novoSk('f'), args: prefixoUniversal.map(v => ({ tipo: 'var', nome: v })) };
        }
      }
      function aplicarSubs(node) {
        if (!node) return node;
        switch (node.tipo) {
          case 'pred': return { tipo: 'pred', nome: node.nome, args: node.args.map(aplicarTermo) };
          case 'and': case 'or': return { tipo: node.tipo, a: aplicarSubs(node.a), b: aplicarSubs(node.b) };
          case 'not': return { tipo: 'not', a: aplicarSubs(node.a) };
          default: return clone(node);
        }
      }
      function aplicarTermo(t) {
        if (!t) return t;
        if (t.tipo === 'var') return subs[t.nome] ? subs[t.nome] : t;
        if (t.tipo === 'func') return { tipo: 'func', nome: t.nome, args: t.args.map(aplicarTermo) };
        return t;
      }
      return aplicarSubs(matriz);
    }

    function paraCNF(node) {
      if (!node) return node;
      if (node.tipo === 'and') return { tipo: 'and', a: paraCNF(node.a), b: paraCNF(node.b) };
      if (node.tipo === 'or') {
        const A = paraCNF(node.a), B = paraCNF(node.b);
        if (A.tipo === 'and') return paraCNF({ tipo: 'and', a: { tipo: 'or', a: A.a, b: B }, b: { tipo: 'or', a: A.b, b: B } });
        if (B.tipo === 'and') return paraCNF({ tipo: 'and', a: { tipo: 'or', a: A, b: B.a }, b: { tipo: 'or', a: A, b: B.b } });
        return { tipo: 'or', a: A, b: B };
      }
      if (node.tipo === 'not') return { tipo: 'not', a: paraCNF(node.a) };
      return clone(node);
    }

    function paraDNF(node) {
      if (!node) return node;
      if (node.tipo === 'or') return { tipo: 'or', a: paraDNF(node.a), b: paraDNF(node.b) };
      if (node.tipo === 'and') {
        const A = paraDNF(node.a), B = paraDNF(node.b);
        if (A.tipo === 'or') return paraDNF({ tipo: 'or', a: { tipo: 'and', a: A.a, b: B }, b: { tipo: 'and', a: A.b, b: B } });
        if (B.tipo === 'or') return paraDNF({ tipo: 'or', a: { tipo: 'and', a: A, b: B.a }, b: { tipo: 'and', a: A, b: B.b } });
        return { tipo: 'and', a: A, b: B };
      }
      if (node.tipo === 'not') return { tipo: 'not', a: paraDNF(node.a) };
      return clone(node);
    }

    function extrairClausulasCNF(node) {
      const clausulas = [];
      function coletarConj(n, out) {
        if (!n) return;
        if (n.tipo === 'and') { coletarConj(n.a, out); coletarConj(n.b, out); return; }
        out.push(n);
      }
      const conj = [];
      coletarConj(node, conj);
      for (const c of conj) {
        const lits = [];
        function coletarDisj(n, arr) {
          if (!n) return;
          if (n.tipo === 'or') { coletarDisj(n.a, arr); coletarDisj(n.b, arr); return; }
          arr.push(n.tipo === 'not' ? { pos: false, lit: n.a } : { pos: true, lit: n });
        }
        coletarDisj(c, lits);
        clausulas.push(lits);
      }
      return clausulas;
    }

    function ehClausulaHorn(clausula) { return clausula.filter(l => l.pos).length <= 1; }
    function classificarClausulaHorn(clausula) {
      const posCount = clausula.filter(l => l.pos).length;
      const negCount = clausula.length - posCount;
      if (posCount === 0 && negCount > 0) return 'goal';
      if (posCount === 1 && negCount === 0) return 'fact';
      if (posCount === 1 && negCount > 0) return 'rule';
      if (posCount === 0 && negCount === 0) return 'empty';
      return 'not-horn';
    }

    function clausulaParaLatex(clausula) {
      if (!clausula || !clausula.length) return '\\square';
      return clausula.map(l => l.pos ? astParaLatex(l.lit) : `\\lnot ${astParaLatex(l.lit)}`).join(' \\lor ');
    }
    function clausulasParaLatex(clausulas) {
      if (!clausulas || !clausulas.length) return '\\emptyset';
      return `\\{ ${clausulas.map(c => `(${clausulaParaLatex(c)})`).join(', ')} \\}`;
    }

    const inputEl = document.getElementById('input');
    const resultsContainer = document.getElementById('resultsContainer');
    let stepCounter = 1;

    function inserirSimbolo(s) {
      const el = inputEl;
      const start = el.selectionStart, end = el.selectionEnd, text = el.value;
      el.value = text.slice(0, start) + s + text.slice(end);
      el.focus();
      el.selectionStart = el.selectionEnd = start + s.length;
    }

    function definirExemplo(s) {
      inputEl.value = s;
    }

    function limparTudo() {
      inputEl.value = '';
      resultsContainer.innerHTML = '';
    }

    function adicionarTitulo(titulo) {
      const h = document.createElement('h3');
      h.textContent = titulo;
      resultsContainer.appendChild(h);
    }

    function adicionarPasso(titulo, latex, extraClass = '') {
      const div = document.createElement('div');
      div.className = `step ${extraClass}`;
      div.innerHTML = `
        <div class="step-number">${stepCounter++}</div>
        <div class="step-content">
            <div class="title">${titulo}</div>
            <div class="formula">\\(${latex}\\)</div>
        </div>`;
      resultsContainer.appendChild(div);
    }

    function executarTudo() {
      resultsContainer.innerHTML = '';
      stepCounter = 1;
      skContador = 0; renomearContador = 0;
      const raw = inputEl.value.trim();
      if (!raw) { alert('Digite uma fórmula LaTeX primeiro.'); return; }

      let ast;
      try {
        ast = analisar(raw);
        if (!ast) throw new Error('O parser retornou um resultado vazio. Verifique a sintaxe.');
      } catch (e) {
        adicionarTitulo("Erro");
        adicionarPasso('Erro no Parser', `\\text{${e.message || 'Entrada inválida'}}`, 'error');
        console.error(e);
        MathJax.typesetPromise();
        return;
      }

      try {
        adicionarTitulo("Transformação para Forma Cláusal");
        adicionarPasso('Fórmula Original', astParaLatex(ast));
        const passo2 = eliminarImplicacoes(ast);
        adicionarPasso('Eliminar → e ↔', astParaLatex(passo2));
        const passo3 = paraNNF(passo2);
        adicionarPasso('NNF (Forma Normal Negativa)', astParaLatex(passo3));
        const passo4 = renomearVariaveisLigadas(passo3);
        adicionarPasso('Renomear Variáveis Ligadas', astParaLatex(passo4));
        const puxado = puxarQuantificadores(passo4);
        const passo5 = construirPrenex(puxado.quantificadores, puxado.matriz);
        adicionarPasso('Forma Prenex', astParaLatex(passo5));
        const passo6 = skolemizar(passo5);
        adicionarPasso('Skolemização (Remover ∃)', astParaLatex(passo6));
        const passo7_cnf = paraCNF(passo6);
        adicionarPasso('CNF (Forma Normal Conjuntiva)', astParaLatex(passo7_cnf));
        const clausulas = extrairClausulasCNF(passo7_cnf);
        adicionarPasso('Forma Cláusal', clausulasParaLatex(clausulas));

        adicionarTitulo("Análise das Cláusulas");
        if (clausulas.length) {
          let analiseHorn = [];
          let todasHorn = true;
          clausulas.forEach((clausula, i) => {
            const ehHorn = ehClausulaHorn(clausula);
            const tipo = classificarClausulaHorn(clausula);
            if (!ehHorn && tipo !== 'empty') todasHorn = false;
            let tipoDesc = { fact: 'Fato', rule: 'Regra', goal: 'Cláusula Objetivo', empty: 'Cláusula Vazia', 'not-horn': 'Não-Horn' }[tipo];
            analiseHorn.push(`C_{${i + 1}}: \\underbrace{(${clausulaParaLatex(clausula)})}_{\\text{${tipoDesc}}}`);
          });
          adicionarPasso('Análise de Cláusulas de Horn', analiseHorn.join('\\\\'));
          adicionarPasso('Resumo Horn', todasHorn ? '\\text{O conjunto de cláusulas é Horn.}' : '\\text{O conjunto de cláusulas não é Horn.}');
        } else {
          adicionarPasso('Análise de Cláusulas de Horn', '\\text{Nenhuma cláusula encontrada.}');
        }

        adicionarTitulo("Forma Alternativa (Comparação)");
        const passo7_dnf = paraDNF(passo6);
        adicionarPasso('DNF (Forma Normal Disjuntiva)', astParaLatex(passo7_dnf));

      } catch (e) {
        adicionarTitulo("Erro");
        adicionarPasso('Erro durante a transformação', `\\text{${e.message || 'Erro inesperado'}}`, 'error');
        console.error(e);
      }
      MathJax.typesetPromise();
    }
  </script>
</body>
</html>
